{-
  TASK 5 - Fibonacci sequence
  Implement a function that generates the Fibonacci
  sequence from N to N+K terms (0<=N<=370; 0<=N+K<=371; 0<=K<=255).
  The first two terms of the Fibonacci sequence are F_0 = 0 and F_1 = 1,
  and the rest are defined as F_n = F_(n-1) + F_(n-2).
  The resulting Fibonacci sequence should be stored in a tuple.
  For example, a request with N = 1 and K = 3 should return a tuple [1, 1, 2],
  and a request with N = 201 and K = 4 should return a tuple
  [453973694165307953197296969697410619233826,
  734544867157818093234908902110449296423351,
  1188518561323126046432205871807859915657177,
  1923063428480944139667114773918309212080528]
-}

;; empty tuple is null() or empty_tuple()? - Second
;; How suppose check restrictions `(0<=N<=370; 0<=N+K<=370; 0<=K<=255)`? Must it throw or return empty tuple? - no need
;; k = 0? empty tuple? - Just try it. It's part of the challenge ðŸ˜‰ - yeap
;; dude i spent like 5 hrs on that, fib(370) overflows the 256-bit integer, so make sure u arent calculating 370 directly,
;;   like the biggest number u should store is fib(369). also if it still bugs after, then just rewrite ur code with more sleep.
;;   cuz i failed for hrs afterwards, then i just decided to rewrite and it just worked and i still have 0 idea why
;; - Sory, I think you are wrong. Just make sure, that edge cases are correct
;; - wait yeah sry ur right, its 371
;; Limit in fibonacci sequence is 371. TVM integer limit is 2**256 = 1.157920892373162e+77 but fibonacci(371n) = 1.5308390447535E+77, which is alraedy larger, than the limit, so I keep getting exit_code=4.
;;   Am I doing something wrong or the limit should be 0<=N+K<371 instead of 0<=N+K<=371?
;; - N <= 370
;;   N + K <= 371
;;   N = 370, K = 1 means to return just [F370]
;; tuple solve(int n, int k) asm """
;;     // asm code
;; """

;; ;; testable
;; tuple fibonacci_sequence(int n, int k) method_id {
;;     return solve(n, k);
;; }

forall X -> (tuple, ()) ~tpush(tuple t, X value) asm "TPUSH";
forall X -> (tuple, ()) push_back (tuple tail, X head) asm "CONS";
forall X -> (tuple, (X)) pop_back (tuple t) asm "UNCONS";

() recv_internal() {
}

;; testable
(tuple) fibonacci_sequence (int n, int k) method_id {
  tuple result = null();
  if (k == 0) { return result; }
  ;; int f = 0;
  ;; if (n == 0) & (k > 1)
  ;; int s = 1;
  ;; int t = f + s;
  ;; int i = 0;
  ;; while (i < n) {
  ;;   i = i + 1;
  ;; }
  return null();
}

